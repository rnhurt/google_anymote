### Generated by rprotoc. DO NOT EDIT!
### <proto file: polo.proto>
# // Copyright 2009 Google Inc. All Rights Reserved.
# 
# option java_outer_classname = "PoloProto";
# option java_package = "com.google.polo.wire.protobuf";
# 
# // OuterMessage - base outer message type used in the protocol.
# 
# message OuterMessage {
# 
#   // MessageType indicates the type of the enclosed message (serialized in the
#   // `payload` field)
#   enum MessageType {
#     // Initialization phase
#     MESSAGE_TYPE_PAIRING_REQUEST = 10;
#     MESSAGE_TYPE_PAIRING_REQUEST_ACK = 11;
# 
#     // Configuration phase
#     MESSAGE_TYPE_OPTIONS = 20;
#     MESSAGE_TYPE_CONFIGURATION = 30;
#     MESSAGE_TYPE_CONFIGURATION_ACK = 31;
# 
#     // Pairing phase
#     MESSAGE_TYPE_SECRET = 40;
#     MESSAGE_TYPE_SECRET_ACK = 41;
#   }
# 
#   // Protocol status states.
#   enum Status {
#     STATUS_OK = 200;
#     STATUS_ERROR = 400;
#     STATUS_BAD_CONFIGURATION = 401;
#     STATUS_BAD_SECRET = 402;
#   }
# 
#   required uint32 protocol_version = 1 [default = 1];
# 
#   // Protocol status. Any status other than STATUS_OK implies a fault.
#   required Status status = 2;
# 
#   // Encapsulated message.  These fields are required if status is STATUS_OK.
#   optional MessageType type = 3;
#   optional bytes payload = 4;
# 
# }
# 
# 
# //
# // Initialization messages
# //
# 
# message PairingRequest {
#   // String name of the service to pair with.  The name used should be an
#   // established convention of the application protocol.
#   required string service_name = 1;
# 
#   // Descriptive name of the client.
#   optional string client_name = 2;
# }
# 
# message PairingRequestAck {
#   // Descriptive name of the server.
#   optional string server_name = 1;
# }
# 
# 
# //
# // Configuration messages
# //
# 
# message Options {
#   message Encoding {
#     enum EncodingType {
#       ENCODING_TYPE_UNKNOWN = 0;
#       ENCODING_TYPE_ALPHANUMERIC = 1;
#       ENCODING_TYPE_NUMERIC = 2;
#       ENCODING_TYPE_HEXADECIMAL = 3;
#       ENCODING_TYPE_QRCODE = 4;
#     }
# 
#     required EncodingType type = 1;
#     required uint32 symbol_length = 2;
#   }
# 
#   enum RoleType {
#     ROLE_TYPE_UNKNOWN = 0;
#     ROLE_TYPE_INPUT = 1;
#     ROLE_TYPE_OUTPUT = 2;
#   }
# 
#   // List of encodings this endpoint accepts when serving as an input device.
#   repeated Encoding input_encodings = 1;
# 
#   // List of encodings this endpoint can generate as an output device.
#   repeated Encoding output_encodings = 2;
# 
#   // Preferred role, if any.
#   optional RoleType preferred_role = 3;
# }
# 
# message Configuration {
#   // The encoding to be used in this session.
#   required Options.Encoding encoding = 1;
# 
#   // The role of the client (ie, the one initiating pairing). This implies the
#   // peer (server) acts as the complementary role.
#   required Options.RoleType client_role = 2;
# }
# 
# message ConfigurationAck {
# }
# 
# 
# //
# // Pairing messages
# //
# 
# message Secret {
#   required bytes secret = 1;
# }
# 
# message SecretAck {
#   required bytes secret = 1;
# }
# 

require 'protobuf/message/message'
require 'protobuf/message/enum'
require 'protobuf/message/service'
require 'protobuf/message/extend'

::Protobuf::OPTIONS[:"java_outer_classname"] = "PoloProto"
::Protobuf::OPTIONS[:"java_package"] = "com.google.polo.wire.protobuf"
class OuterMessage < ::Protobuf::Message
  defined_in __FILE__
  class MessageType < ::Protobuf::Enum
    defined_in __FILE__
    MESSAGE_TYPE_PAIRING_REQUEST = value(:MESSAGE_TYPE_PAIRING_REQUEST, 10)
    MESSAGE_TYPE_PAIRING_REQUEST_ACK = value(:MESSAGE_TYPE_PAIRING_REQUEST_ACK, 11)
    MESSAGE_TYPE_OPTIONS = value(:MESSAGE_TYPE_OPTIONS, 20)
    MESSAGE_TYPE_CONFIGURATION = value(:MESSAGE_TYPE_CONFIGURATION, 30)
    MESSAGE_TYPE_CONFIGURATION_ACK = value(:MESSAGE_TYPE_CONFIGURATION_ACK, 31)
    MESSAGE_TYPE_SECRET = value(:MESSAGE_TYPE_SECRET, 40)
    MESSAGE_TYPE_SECRET_ACK = value(:MESSAGE_TYPE_SECRET_ACK, 41)
  end
  class Status < ::Protobuf::Enum
    defined_in __FILE__
    STATUS_OK = value(:STATUS_OK, 200)
    STATUS_ERROR = value(:STATUS_ERROR, 400)
    STATUS_BAD_CONFIGURATION = value(:STATUS_BAD_CONFIGURATION, 401)
    STATUS_BAD_SECRET = value(:STATUS_BAD_SECRET, 402)
  end
  required :uint32, :protocol_version, 1, :default => 1
  required :Status, :status, 2
  optional :MessageType, :type, 3
  optional :bytes, :payload, 4
end

class PairingRequest < ::Protobuf::Message
  defined_in __FILE__
  required :string, :service_name, 1
  optional :string, :client_name, 2
end

class PairingRequestAck < ::Protobuf::Message
  defined_in __FILE__
  optional :string, :server_name, 1
end

class Options < ::Protobuf::Message
  defined_in __FILE__
  class Encoding < ::Protobuf::Message
    defined_in __FILE__
    class EncodingType < ::Protobuf::Enum
      defined_in __FILE__
      ENCODING_TYPE_UNKNOWN = value(:ENCODING_TYPE_UNKNOWN, 0)
      ENCODING_TYPE_ALPHANUMERIC = value(:ENCODING_TYPE_ALPHANUMERIC, 1)
      ENCODING_TYPE_NUMERIC = value(:ENCODING_TYPE_NUMERIC, 2)
      ENCODING_TYPE_HEXADECIMAL = value(:ENCODING_TYPE_HEXADECIMAL, 3)
      ENCODING_TYPE_QRCODE = value(:ENCODING_TYPE_QRCODE, 4)
    end
    required :EncodingType, :type, 1
    required :uint32, :symbol_length, 2
  end
  class RoleType < ::Protobuf::Enum
    defined_in __FILE__
    ROLE_TYPE_UNKNOWN = value(:ROLE_TYPE_UNKNOWN, 0)
    ROLE_TYPE_INPUT = value(:ROLE_TYPE_INPUT, 1)
    ROLE_TYPE_OUTPUT = value(:ROLE_TYPE_OUTPUT, 2)
  end
  repeated :Encoding, :input_encodings, 1
  repeated :Encoding, :output_encodings, 2
  optional :RoleType, :preferred_role, 3
end
class Configuration < ::Protobuf::Message
  defined_in __FILE__
  required :'Options::Encoding', :encoding, 1
  required :'Options::RoleType', :client_role, 2
end
class ConfigurationAck < ::Protobuf::Message
  defined_in __FILE__
end
class Secret < ::Protobuf::Message
  defined_in __FILE__
  required :bytes, :secret, 1
end
class SecretAck < ::Protobuf::Message
  defined_in __FILE__
  required :bytes, :secret, 1
end